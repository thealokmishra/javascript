// javascript
// 1)Synchronous: by default in JavaScript, code is executed in a synchronous manner, which means that the code is executed in order, one line at a time. Each line of code must finish executing before the next line can start. This can lead to blocking behavior if a particular operation takes a long time to complete, such as fetching data from a server or performing complex calculations.
// 2)Asynchronous: allows certain operations to be executed in the background while the main thread continues to run. This means that you can initiate an asynchronous operation, such as fetching data from a server, and then continue with other tasks without waiting for the operation to complete. Once the asynchronous operation is finished, a callback function or a promise can be used to handle the result.
// Single-threaded: JavaScript runs on a single thread, which means that only one operation can be executed at a time. However, JavaScript can still handle asynchronous operations using mechanisms like callbacks, promises, and async/await. This allows developers to write non-blocking code that can perform tasks concurrently without freezing the user interface or blocking other operations.

// Blocking code: A blocking code is a piece of code that prevents the execution of other code until it has completed. For example, if you have a long-running loop or a synchronous function that takes a long time to execute, it will block the main thread and prevent any other code from running until it finishes. This can lead to a poor user experience, as the application may become unresponsive during the execution of the blocking code.
// e.g.
function blockingFunction() {
  for (let i = 0; i < 1e9; i++) {}
}
// Non-blocking code: A non-blocking code is a piece of code that allows other code to run while it is executing. This is typically achieved through asynchronous programming techniques, such as callbacks, promises, or async/await. Non-blocking code allows the application to remain responsive and perform other tasks while waiting for an operation to complete, such as fetching data from a server or performing a time-consuming calculation.

// non-blocking code is not always better for example suppose you have to show a notification: that data is saved, to user after some data is saved in db, but that operation takes long time, so if you write async code in this  it'll be bad cause you showed notification that data saved without actually saving data in db, so in this case you should write blocking code to show notification after data is saved in db. So it depends on the use case whether to write blocking code or non-blocking code.

// in js event loop is responsible for handling asynchronous operations and ensuring that they are executed in the correct order. When an asynchronous operation is initiated, it is added to the event loop's queue. The event loop continuously checks the queue for any pending operations and executes them when they are ready. This allows JavaScript to handle multiple asynchronous operations concurrently without blocking the main thread, ensuring a responsive user experience.
// priority queue: in js event loop, there is a concept of a priority queue, which is used to manage the execution of asynchronous operations. The priority queue allows certain operations to be executed before others based on their priority level. For example, if there are multiple asynchronous operations waiting in the queue, the event loop will prioritize those with higher priority levels and execute them first. This helps ensure that critical tasks are handled promptly while still allowing less urgent tasks to be processed in a timely manner.
// microtasks: In JavaScript, microtasks are a type of asynchronous operation that is executed after the current synchronous code has finished executing but before any other asynchronous operations in the event loop. Microtasks are typically used for tasks that need to be executed immediately after the current code, such as promises and mutation observers. They have a higher priority than regular asynchronous tasks, which means that they will be executed before any other tasks in the event loop, ensuring that they are processed as soon as possible.
// task queue: In JavaScript, the task queue (also known as the macrotask queue) is a queue that holds asynchronous tasks that are scheduled to be executed after the current synchronous code has finished executing. Tasks in the task queue include things like setTimeout, setInterval, and I/O operations. When the event loop is ready to process tasks, it will first check the microtask queue for any pending microtasks and execute them before moving on to the task queue. This ensures that microtasks are given higher priority and are executed before any other tasks in the event loop, allowing for a more responsive user experience.
